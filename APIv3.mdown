# API v3 Ideas

## Principles

* We should make use of the HTTP verbs
* use JSON as much as possible.

### Weak points

We must find a nice way to identify the scenarios that should be saved and those that can be pruned. Now we have ~25k scenarios. But we hardly need more than 1k - most of them are leftovers. The API should include a way to mark the scenarios to be stored and those that can be dropped.

Another issue is the scenario ownership: now we have `author` and `user_id` field. If we add the `source` field then the `user_id` field could be relative to the client application. The ETM's `saved_scenario` object **can be migrated to user profile with a serialized hash 'saved_scenarios'**

### DB changes

It would be nice to add a source column, to store the ETE client name and track which applications are creating the scenarios.

Country and region should be merged into a single `area_code` column.

#### ETE Scenarios:

* decide what to do with `author` and `user_id` columns
* drop column `present_updated_at` or `updated_at`- one is enough
* user_values: store values as json - it is more readable and way faster. Only downside is that hash keys are now strings rather than integers. Rails 3.2 ActiveRecord store would make this even more convenient.

## Scenarios

### Get a single scenario [IMPLEMENTED, but the output is the old scenario#to_json]

#### Request

    GET /scenarios/:id

#### Response

    Status: 200 OK

    {
      "title": "My scenario"
      "url": "http://et-engine.com/scenarios/999",
      "id": 999,
      "area_code": "nl",
      "end_year": 2040,
      "template": 12345,
      "source": "ETM"
    }

If the scenario is missing then the action returns an empty hash with a 404 HTTP status code.

### Get predefined scenarios [IMPLEMENTED]

#### Request

    GET /scenarios/templates

#### Response

    Status: 200 OK

    [
    {<scenario>},
    {<scenario>},
    ...
    ]
]
### Create a new scenario

#### Request

    POST /scenarios

* `title`: optional string
* `area_code`: optional string, the default is nl. It's the unique area identifier - no more region/country duplication
* `end_year`: optional integer, default is 2040
* `source`: optional (but highly recommended) required string, the application that makes the request
* `template`: optional id of the scenario used as template / preset_scenario_id

Implemented, but the attributes are still using the old names.

##### Example

    {
      "title": "My scenario",
      "area_code": "nl",
      "end_year": 2040,
      "template": 12345,
      "source": "ETM"
    }

#### Response

    Status: 201 Created

    {
      "url": "http://et-engine.com/scenarios/999",
      "id": 999,
      "title": "My scenario",
      "area_code": "nl",
      "end_year": 2040,
      "template": 12345,
      "source": "ETM"
    }

### Updating querying a scenario

The two operations should better be separated, but that would probably make the applications trigger too many requests. Since gqueries are basically read, safe operations, the right HTTP verb should be GET, but then we'd have the annoying URL length limit issues with IE.
The slider update is a proper PATCH request instead.

#### Request

    PUT /scenarios/:id

* `inputs`: optional hash {:input_key => :value }
* `reset`: optional boolean (default: false). If true the scenario inputs will first be reset. This means that the scenario will use only the inputs we're passing with the current request. Used by the energymixer
* `gqueries`: optional array of gqueries to run
* `scenario`: hash with the scenario attributes. Its `user_values` are merged with the existing values, because otherwise we should send the entire input sets with every request.

Partially implemented: the `gqueries` and `reset` attributes are still ignored.

##### Example

    {
      "reset": true,
      "gqueries": [
        "gquery_1",
        "gquery_2"
      ],
      "scenario": {
        "title": "New title",
        "user_values": {
          "123": 4.56,
          "124": 5.67
        }
      }
    }

#### Response

The gquery result is a hash rather than an array.

    Status: 200 OK

    {
      "scenario": <scenario>,
      "gqueries": {
        "gquery_1": {
          "present": 123,
          "future": 456,
          "unit": "MJ"
        },
        "gquery_2": {
          "present": 123,
          "future": 456,
          "unit": "euro"
        },
      }
    }

About gquery results with errors: to make the client applications more robust the single gquery should carry its errors, using something like:

    "foo" : {
      "error": "unknown gquery. Please check gquery list on http://et-engine.com."
      "unit": "MJ"
    }

Other things to consider: deal with gqueries that return strings or array of strings (hello merit_order).

## Inputs

Input values are scenario-dependent, so we should pass a scenario id. We should decide whether identifying inputs by key exclusively or by id, too. If the `scenario_id` parameter is missing then the engine will use the latest scenario.

### Get all inputs details

#### Request

    GET /inputs
    GET /scenarios/:scenario_id/inputs

#### Response

    Status: 200 OK

    {
      "agriculture_electricity_demand": {
        "share_group": "foobar",
        "max": 5,
        "min": -5,
        "default": 0,
        "user": 3
      },-
      "agriculture_heat_demand": {
        "max": 5,
        "min": -5,
        "default": 0,
        "user": 2.3
      },
      ...
    }

* `default`: input start value
* `user`: user-set value. Not available if null
* `max`
* `min`
* `share_group`: Not available if null or empty

### Get a single input details

#### Request

    GET /inputs/:code
    GET /scenarios/:scenario_id/inputs/:code

#### Response

    Status: 200 OK

    {
      "code": "households_replacement_of_existing_houses",
      "share_group": "",
      "max": 5,
      "min": 0,
      "default": 0
    }

Just like the entire inputs list, but not indexed by input code. The attribute code is added to the output.

#### Errors

If the input doesn't exist the server returns an HTTP 404 error and a message:

    Status: 404

    {
      "errors": ["Input not found"]
    }

### Get a subset of input details

Not implemented yet.

#### Request

    GET /scenarios/:input_id/inputs/:keys
    GET /scenarios/:input_id/inputs/1,2,3,4,5,10,11,12,13

#### Response

    Status: 200 OK

    [
      {
        "key": "input_foobar",
        "id": 1
        "start_value": 1000,
        "end_value": 2000,
        "label": "1€/Kg",
        "current_value": 1500
      },
    [...]
      {
        "key": "input_foobar_2",
        "id": 13
        "start_value": 1000,
        "end_value": 2000,
        "label": "1€/Kg",
        "current_value": 1500
      }
    ]

## Converters

### Get a converter details

This information should be seen on the graph diagram (maybe when the user clicks on a node and wants to see the details) and on the ETM, when the user clicks on the converter info link (now we're loading an iframe). Do we ever need converter info outside the scope of a scenario? We could use the `/converters/:code` URL to get the generic converter attributes (those that don't require an active scenario) and `/scenarios/:scenario_id/converters/:code` to get the attributes for a specific scenario.

Implemented.

#### Request

    GET /converters/:code

If the scenario_id is missing then the controller will use the latest scenario.

#### Response

    Status: 200 OK

    {
        "code": "biomass_chp_industry_energetic",
        "sector": "industry",
        "use": "energetic",
        "groups": ["electricity_production", "central_production"],
        "energy_balance_group": "central CHPs",
        "attributes": {
            "operational": {
                "typical_nominal_input_capacity": {
                    "present": 162.60162601626,
                    "future": 162.60162601626
                },
                "full_load_hours": {
                    "present": 5394.19087136929,
                    "future": 5394.19087136929
                },
                ...
            },
            "cost": {
                "purchase_price_per_mw_input": {
                    "present": 412050.0,
                    "future": 412050.0
                },
                "installing_costs_per_mw_input": {
                    "present": 0.0,
                    "future": 0.0
                },
                ...
        },
        "calculations": {
            "additional_investment_ccs_per_mwe": {
                "present": 0.0,
                "future": 0.0
            },
            "cost_of_capital_per_mw_input": {
                "present": 23898.9,
                "future": 23898.9
            },
            ...
       }
    }

### Converter details for a specific scenario

Implemented

#### Request

    GET /scenarios/:scenario_id/converters/:key

#### Response

See above, the response is identical.
